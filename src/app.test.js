/* üî•üî•
  üëâ DO NOT EDIT THIS FILE üëà
üî•üî• */

import request from 'supertest'
import fs from 'fs/promises'
import { resolve } from 'path'
//import { randomUUID } from 'crypto'

function randomUUID() {
  return `${math.random()}`
}

import { URL } from 'url'

import app from './app.js'

const dirname = new URL('.', import.meta.url).pathname

/*
  Objectif : le serveur doit contenir certaines routes effectuant des actions pr√©cises
*/
describe('the server works as expected', () => {
  describe('server is running', () => {
    test('GET / returns a 200', async () => {
      const response = await request(app).get('/')

      expect(response.statusCode).toBe(200)
    })
  })

  /*
    Objectifs : maitriser les m√©thodes de l'objet `res` (la `Server Response`)
    Ainsi que les donn√©es JSON
  */
  describe('GET /', () => {
    const url = '/'

    test('return json format', async () => {
      const response = await request(app).get(url)

      expect(response.text).toEqual('{"message":"Server is running"}')
    })

    test('return json format', async () => {
      const response = await request(app).get(url)

      expect(response.headers).toHaveProperty(
        'content-type',
        'application/json; charset=utf-8',
      )
      expect(response.body).toStrictEqual({ message: 'Server is running' })
    })
  })

  /*
    Objectifs: maitriser les propri√©t√©s de l'objet `req` (la `Client Request`)
  */
  describe('GET /hello', () => {
    const url = '/hello'

    test('return json format', async () => {
      const response = await request(app).get(url)

      expect(response.statusCode).toBe(200)
      expect(response.body).toStrictEqual({ message: 'Hello world' })
    })
  })

  /*
    Objectifs: s'assurer que les routes qui n'existent pas retournent un code d'erreur 404
    Avec un message d'erreur stipulant "URL not found"
  */
  describe('GET|PUT /notfound', () => {
    const url = `/notfound-${randomUUID()}`

    test('return error message with status code 404', async () => {
      const response = await request(app).get(url)

      expect(response.statusCode).toBe(404)
      expect(response.body).toStrictEqual({
        error: `URL not found: GET ${url}`,
      })
    })

    test('return error message with status code 404', async () => {
      const response = await request(app).put(url)

      expect(response.statusCode).toBe(404)
      expect(response.body).toStrictEqual({
        error: `URL not found: PUT ${url}`,
      })
    })
  })

  /*
    Objectifs: maitriser les param√®tres d'URL
  */
  describe('GET /hello?name=<params>', () => {
    const url = '/hello'

    test('still returns "Hello world" if no name is passed', async () => {
      const response = await request(app).get(url).query({ name: '' })

      expect(response.body).toStrictEqual({ message: 'Hello world' })
    })

    test('returns "Hello Bob" is Bob is passed as the name', async () => {
      const response = await request(app).get(url).query({ name: 'Bob' })

      expect(response.body).toStrictEqual({ message: 'Hello Bob' })
    })

    test('returns "Hello <name>", whatever the "<name>" is', async () => {
      const name = `Alice${randomUUID()}` // Make the name dynamic for testing purpose
      const response = await request(app).get(url).query({ name })

      expect(response.body).toStrictEqual({ message: `Hello ${name}` })
    })
  })

  /*
    Objectifs : cr√©er une premi√®re route POST qui accepte un `body``
  */
  describe('POST /message', () => {
    const url = '/message'

    test('returns statusCode 200', async () => {
      const response = await request(app).post(url)

      expect(response.statusCode).toStrictEqual(200)
    })

    test('returns a success message along with the data sent', async () => {
      const data = {
        name: 'Bob',
        message: 'Hello world',
        id: randomUUID(), // random string for testing purpose
      }
      const response = await request(app).post(url).send(data)

      expect(response.body).toStrictEqual({
        message: 'Message received',
        data,
      })
    })

    test('return an error if bad data is sent', async () => {
      const data = 'not json'
      const response = await request(app).post(url).send(data)

      expect(response.statusCode).toStrictEqual(400)
      expect(response.body).toStrictEqual({
        error: 'Bad Request',
      })
    })
  })
})

/*
  Objectifs : Contr√¥ler la s√©curit√© du code
*/
describe('the server sanitizes user inputs', () => {
  test('inputs in query strings are sanitized', async () => {
    const response = await request(app)
      .get('/hello')
      .query({ name: '<script>alert("Bob")</script>' })

    expect(response.body).toStrictEqual({
      message: 'Hello &lt;script&gt;alert("Bob")&lt;/script&gt;',
    })
  })
})

/*
  Objectifs : Contr√¥ler la qualit√© du code
*/
describe('the code is splitted in multiple and well organised files', () => {
  test('the file `./app.js` exists', async () => {
    try {
      const path = resolve(dirname, 'app.js')
      const filePath = await fs.realpath(path)

      expect(filePath).toContain(path)
    } catch (e) {
      expect(e).not.toBeDefined()
    }
  })

  test('the directory `./routes/` exists', async () => {
    try {
      const path = resolve(dirname, 'routes')
      const filePath = await fs.realpath(path)

      expect(filePath).toContain(path)
    } catch (e) {
      expect(e).not.toBeDefined()
    }
  })

  test('the file `./routes/hello.js` exists', async () => {
    try {
      const path = resolve(dirname, 'routes/hello.js')
      const filePath = await fs.realpath(path)

      expect(filePath).toContain(path)
    } catch (e) {
      expect(e).not.toBeDefined()
    }
  })
})
